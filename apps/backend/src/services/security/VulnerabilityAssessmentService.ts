import { VulnerabilityReport, VulnerabilityReportModel } from '../../models/VulnerabilityReport';

export interface VulnerabilityScanConfig {
  scan_id: string;
  target_urls: string[];
  scan_profile: 'quick' | 'baseline' | 'owasp-top-10' | 'comprehensive';
  max_duration_minutes: number;
  performance_limit_percent: number;
  constitutional_requirements: {
    phone_protection_check: boolean;
    business_isolation_check: boolean;
    gdpr_compliance_check: boolean;
  };
}

export interface VulnerabilityScanResult {
  scan_id: string;
  status: 'pending' | 'running' | 'completed' | 'failed';
  started_at: string;
  completed_at?: string;
  scan_progress_percent: number;
  performance_impact: {
    cpu_usage_percent: number;
    network_overhead_percent: number;
    response_time_impact_percent: number;
    total_overhead_percent: number;
  };
  vulnerabilities_found: VulnerabilityReport[];
  constitutional_compliance: {
    performance_limit_met: boolean;
    phone_protection_validated: boolean;
    business_isolation_verified: boolean;
    gdpr_requirements_checked: boolean;
  };
  scan_statistics: {
    total_requests: number;
    successful_requests: number;
    failed_requests: number;
    alerts_raised: number;
    false_positives_filtered: number;
  };
  errors: string[];
}

export class VulnerabilityAssessmentService {
  private static readonly MAX_PERFORMANCE_IMPACT = 10; // Constitutional limit: ≤10%
  private static readonly OWASP_ZAP_CONFIG = {
    host: 'localhost',
    port: 8080,
    apiKey: process.env.OWASP_ZAP_API_KEY || 'development-key'
  };
  
  private runningScans: Map<string, VulnerabilityScanResult> = new Map();
  
  async startVulnerabilityScan(config: VulnerabilityScanConfig): Promise<VulnerabilityScanResult> {
    // Validate constitutional requirements
    this.validateScanConfig(config);
    
    const scanResult: VulnerabilityScanResult = {
      scan_id: config.scan_id,
      status: 'pending',
      started_at: new Date().toISOString(),
      scan_progress_percent: 0,
      performance_impact: {
        cpu_usage_percent: 0,
        network_overhead_percent: 0,
        response_time_impact_percent: 0,
        total_overhead_percent: 0
      },
      vulnerabilities_found: [],
      constitutional_compliance: {
        performance_limit_met: true,
        phone_protection_validated: false,
        business_isolation_verified: false,
        gdpr_requirements_checked: false
      },
      scan_statistics: {
        total_requests: 0,
        successful_requests: 0,
        failed_requests: 0,
        alerts_raised: 0,
        false_positives_filtered: 0
      },
      errors: []
    };
    
    this.runningScans.set(config.scan_id, scanResult);
    
    // Start scan asynchronously
    this.runVulnerabilityScanAsync(config, scanResult).catch(error => {
      scanResult.status = 'failed';
      scanResult.errors.push(error.message);
      scanResult.completed_at = new Date().toISOString();
    });
    
    return scanResult;
  }
  
  private async runVulnerabilityScanAsync(
    config: VulnerabilityScanConfig, 
    scanResult: VulnerabilityScanResult
  ): Promise<void> {
    try {
      scanResult.status = 'running';
      
      // Initialize performance monitoring
      const performanceMonitor = new ScanPerformanceMonitor();
      performanceMonitor.start();
      
      // Run OWASP ZAP scan
      await this.executeOwaspZapScan(config, scanResult, performanceMonitor);
      
      // Check constitutional compliance
      if (config.constitutional_requirements.phone_protection_check) {
        await this.validatePhoneProtection(config, scanResult);
      }
      
      if (config.constitutional_requirements.business_isolation_check) {
        await this.validateBusinessIsolation(config, scanResult);
      }
      
      if (config.constitutional_requirements.gdpr_compliance_check) {
        await this.validateGDPRCompliance(config, scanResult);
      }
      
      // Finalize scan
      scanResult.performance_impact = performanceMonitor.getFinalImpact();
      this.validatePerformanceCompliance(scanResult);
      
      scanResult.status = 'completed';
      scanResult.completed_at = new Date().toISOString();
      scanResult.scan_progress_percent = 100;
      
    } catch (error) {
      scanResult.status = 'failed';
      scanResult.errors.push(error.message);
      scanResult.completed_at = new Date().toISOString();
    }
  }
  
  private async executeOwaspZapScan(
    config: VulnerabilityScanConfig,
    scanResult: VulnerabilityScanResult,
    performanceMonitor: ScanPerformanceMonitor
  ): Promise<void> {
    const zapClient = new OwaspZapClient(this.OWASP_ZAP_CONFIG);
    
    try {
      // Configure scan based on profile
      const scanConfig = this.buildZapScanConfig(config);
      
      // Start spider scan for each target URL
      for (const url of config.target_urls) {
        scanResult.scan_progress_percent = 10;
        
        // Spider scan to discover URLs
        const spiderId = await zapClient.startSpider(url, scanConfig.spider);
        await this.waitForSpiderCompletion(zapClient, spiderId, scanResult);
        
        scanResult.scan_progress_percent = 40;
        
        // Active vulnerability scan
        const activeScanId = await zapClient.startActiveScan(url, scanConfig.activeScan);
        await this.waitForActiveScanCompletion(zapClient, activeScanId, scanResult, performanceMonitor);
        
        scanResult.scan_progress_percent = 80;
      }
      
      // Retrieve and process alerts
      const alerts = await zapClient.getAlerts();
      scanResult.scan_statistics.alerts_raised = alerts.length;
      
      // Convert ZAP alerts to VulnerabilityReport objects
      for (const alert of alerts) {
        const vulnerability = this.convertZapAlertToVulnerability(alert, config);
        
        // Filter false positives
        if (this.isValidVulnerability(vulnerability)) {
          scanResult.vulnerabilities_found.push(vulnerability);
        } else {
          scanResult.scan_statistics.false_positives_filtered++;
        }
      }
      
    } catch (error) {
      throw new Error(`OWASP ZAP scan failed: ${error.message}`);
    }
  }
  
  private async validatePhoneProtection(
    config: VulnerabilityScanConfig,
    scanResult: VulnerabilityScanResult
  ): Promise<void> {
    // Check for phone number exposure vulnerabilities
    const phoneExposureVulns = scanResult.vulnerabilities_found.filter(vuln =>
      vuln.vulnerability_category === 'data_exposure' &&
      vuln.description.toLowerCase().includes('phone')
    );
    
    if (phoneExposureVulns.length === 0) {
      scanResult.constitutional_compliance.phone_protection_validated = true;
    } else {
      // Mark phone exposure vulnerabilities as constitutional violations
      phoneExposureVulns.forEach(vuln => {
        vuln.constitutional_impact.phone_number_protection = 'violation';
        vuln.remediation_priority = 'critical'; // Constitutional violation requires immediate attention
      });
      
      scanResult.errors.push(`Constitutional violation: ${phoneExposureVulns.length} phone number exposure vulnerabilities found`);
    }
  }
  
  private async validateBusinessIsolation(
    config: VulnerabilityScanConfig,
    scanResult: VulnerabilityScanResult
  ): Promise<void> {
    // Check for business data isolation vulnerabilities
    const isolationVulns = scanResult.vulnerabilities_found.filter(vuln =>
      vuln.vulnerability_category === 'authorization' ||
      (vuln.vulnerability_category === 'data_exposure' && vuln.description.toLowerCase().includes('business'))
    );
    
    if (isolationVulns.length === 0) {
      scanResult.constitutional_compliance.business_isolation_verified = true;
    } else {
      // Mark business isolation vulnerabilities as constitutional violations
      isolationVulns.forEach(vuln => {
        vuln.constitutional_impact.business_data_isolation = 'violation';
        vuln.remediation_priority = 'critical';
      });
      
      scanResult.errors.push(`Constitutional violation: ${isolationVulns.length} business data isolation vulnerabilities found`);
    }
  }
  
  private async validateGDPRCompliance(
    config: VulnerabilityScanConfig,
    scanResult: VulnerabilityScanResult
  ): Promise<void> {
    // Check for GDPR compliance issues
    const gdprVulns = scanResult.vulnerabilities_found.filter(vuln =>
      vuln.vulnerability_category === 'data_privacy' ||
      vuln.description.toLowerCase().includes('gdpr') ||
      vuln.description.toLowerCase().includes('privacy')
    );
    
    if (gdprVulns.length === 0) {
      scanResult.constitutional_compliance.gdpr_requirements_checked = true;
    } else {
      // Mark GDPR vulnerabilities as constitutional violations
      gdprVulns.forEach(vuln => {
        vuln.constitutional_impact.gdpr_compliance = 'violation';
        vuln.remediation_priority = 'critical';
      });
      
      scanResult.errors.push(`Constitutional violation: ${gdprVulns.length} GDPR compliance vulnerabilities found`);
    }
  }
  
  private validatePerformanceCompliance(scanResult: VulnerabilityScanResult): void {
    if (scanResult.performance_impact.total_overhead_percent > this.MAX_PERFORMANCE_IMPACT) {
      scanResult.constitutional_compliance.performance_limit_met = false;
      scanResult.errors.push(
        `Constitutional violation: Scan performance impact ${scanResult.performance_impact.total_overhead_percent}% exceeds 10% limit`
      );
    }
  }
  
  private validateScanConfig(config: VulnerabilityScanConfig): void {
    if (config.performance_limit_percent > this.MAX_PERFORMANCE_IMPACT) {
      throw new Error(`Constitutional violation: Performance limit ${config.performance_limit_percent}% exceeds 10% maximum`);
    }
    
    if (config.max_duration_minutes > 60) {
      throw new Error('Scan duration cannot exceed 60 minutes');
    }
    
    if (config.target_urls.length === 0) {
      throw new Error('At least one target URL must be specified');
    }
  }
  
  private buildZapScanConfig(config: VulnerabilityScanConfig) {
    const profiles = {
      'quick': {
        spider: { maxDepth: 2, maxChildren: 10 },
        activeScan: { policy: 'Light', maxRuleDuration: 5 }
      },
      'baseline': {
        spider: { maxDepth: 5, maxChildren: 50 },
        activeScan: { policy: 'Medium', maxRuleDuration: 10 }
      },
      'owasp-top-10': {
        spider: { maxDepth: 5, maxChildren: 100 },
        activeScan: { policy: 'OWASP_TOP_10', maxRuleDuration: 15 }
      },
      'comprehensive': {
        spider: { maxDepth: 10, maxChildren: 200 },
        activeScan: { policy: 'High', maxRuleDuration: 25 }
      }
    };
    
    return profiles[config.scan_profile];
  }
  
  private convertZapAlertToVulnerability(zapAlert: any, config: VulnerabilityScanConfig): VulnerabilityReport {
    return {
      vulnerability_id: crypto.randomUUID(),
      title: zapAlert.name,
      description: zapAlert.description,
      severity: this.mapZapRiskToSeverity(zapAlert.risk),
      vulnerability_category: this.mapZapCategoryToCategory(zapAlert.pluginId),
      affected_components: [zapAlert.url],
      cvss_score: this.calculateCvssFromZap(zapAlert),
      cvss_metrics: this.buildCvssMetrics(zapAlert),
      owasp_category: this.mapToOwaspCategory(zapAlert.pluginId),
      discovered_at: new Date().toISOString(),
      status: 'open',
      remediation_status: 'pending',
      remediation_priority: this.calculateRemediationPriority(zapAlert),
      remediation_deadline: this.calculateRemediationDeadline(zapAlert),
      constitutional_impact: {
        phone_number_protection: 'not_applicable',
        business_data_isolation: 'not_applicable',
        gdpr_compliance: 'not_applicable'
      },
      technical_details: {
        attack_vector: zapAlert.attack || '',
        evidence: zapAlert.evidence || '',
        request_response: {
          request: zapAlert.request || '',
          response: zapAlert.response || ''
        },
        reproduction_steps: zapAlert.solution ? [zapAlert.solution] : []
      },
      remediation_guidance: {
        immediate_actions: [zapAlert.solution || 'Review vulnerability details'],
        long_term_fixes: [],
        code_changes_required: zapAlert.solution?.includes('code') || false,
        testing_required: true
      }
    } as VulnerabilityReport;
  }
  
  private mapZapRiskToSeverity(zapRisk: string): 'low' | 'medium' | 'high' | 'critical' {
    const mapping: Record<string, 'low' | 'medium' | 'high' | 'critical'> = {
      'Low': 'low',
      'Medium': 'medium',
      'High': 'high',
      'Critical': 'critical'
    };
    return mapping[zapRisk] || 'medium';
  }
  
  private mapZapCategoryToCategory(pluginId: string): string {
    const categoryMapping: Record<string, string> = {
      '10011': 'authentication',
      '10015': 'authorization',
      '10016': 'data_exposure',
      '10017': 'data_privacy',
      '10020': 'injection',
      '10021': 'xss'
    };
    return categoryMapping[pluginId] || 'misconfiguration';
  }
  
  private mapToOwaspCategory(pluginId: string): string {
    const owaspMapping: Record<string, string> = {
      '10011': 'A01:2021 – Broken Access Control',
      '10015': 'A01:2021 – Broken Access Control',
      '10016': 'A02:2021 – Cryptographic Failures',
      '10017': 'A02:2021 – Cryptographic Failures',
      '10020': 'A03:2021 – Injection',
      '10021': 'A03:2021 – Injection'
    };
    return owaspMapping[pluginId] || 'A10:2021 – Server-Side Request Forgery';
  }
  
  private calculateCvssFromZap(zapAlert: any): number {
    // Simplified CVSS calculation based on ZAP risk
    const riskScores: Record<string, number> = {
      'Low': 3.9,
      'Medium': 6.9,
      'High': 8.9,
      'Critical': 10.0
    };
    return riskScores[zapAlert.risk] || 5.0;
  }
  
  private buildCvssMetrics(zapAlert: any): any {
    // Simplified CVSS metrics
    return {
      version: '3.1',
      attackVector: 'Network',
      attackComplexity: 'Low',
      privilegesRequired: 'None',
      userInteraction: 'None',
      scope: 'Unchanged',
      confidentialityImpact: 'High',
      integrityImpact: 'High',
      availabilityImpact: 'High'
    };
  }
  
  private calculateRemediationPriority(zapAlert: any): 'low' | 'medium' | 'high' | 'critical' {
    return this.mapZapRiskToSeverity(zapAlert.risk);
  }
  
  private calculateRemediationDeadline(zapAlert: any): string {
    // Calculate deadline based on severity
    const severityDays: Record<string, number> = {
      'Critical': 1,
      'High': 7,
      'Medium': 30,
      'Low': 90
    };
    
    const days = severityDays[zapAlert.risk] || 30;
    const deadline = new Date();
    deadline.setDate(deadline.getDate() + days);
    
    return deadline.toISOString();
  }
  
  private isValidVulnerability(vulnerability: VulnerabilityReport): boolean {
    // Filter out common false positives
    const falsePositiveIndicators = [
      'informational',
      'false positive',
      'test page',
      'example'
    ];
    
    const description = vulnerability.description.toLowerCase();
    return !falsePositiveIndicators.some(indicator => description.includes(indicator));
  }
  
  private async waitForSpiderCompletion(
    zapClient: OwaspZapClient,
    spiderId: string,
    scanResult: VulnerabilityScanResult
  ): Promise<void> {
    while (true) {
      const status = await zapClient.getSpiderStatus(spiderId);
      scanResult.scan_progress_percent = Math.min(10 + (status.progress * 0.3), 40);
      
      if (status.status === 'complete') break;
      await new Promise(resolve => setTimeout(resolve, 1000));
    }
  }
  
  private async waitForActiveScanCompletion(
    zapClient: OwaspZapClient,
    scanId: string,
    scanResult: VulnerabilityScanResult,
    performanceMonitor: ScanPerformanceMonitor
  ): Promise<void> {
    while (true) {
      const status = await zapClient.getActiveScanStatus(scanId);
      scanResult.scan_progress_percent = Math.min(40 + (status.progress * 0.4), 80);
      
      // Check performance impact during scan
      const currentImpact = performanceMonitor.getCurrentImpact();
      if (currentImpact.total_overhead_percent > this.MAX_PERFORMANCE_IMPACT) {
        await zapClient.stopActiveScan(scanId);
        throw new Error(`Constitutional violation: Scan performance impact ${currentImpact.total_overhead_percent}% exceeds 10% limit`);
      }
      
      scanResult.performance_impact = currentImpact;
      
      if (status.status === 'complete') break;
      await new Promise(resolve => setTimeout(resolve, 2000));
    }
  }
  
  getScanStatus(scanId: string): VulnerabilityScanResult | null {
    return this.runningScans.get(scanId) || null;
  }
  
  getAllScans(): VulnerabilityScanResult[] {
    return Array.from(this.runningScans.values());
  }
  
  async cancelScan(scanId: string): Promise<boolean> {
    const scan = this.runningScans.get(scanId);
    if (scan && scan.status === 'running') {
      // In production, would stop actual ZAP scan
      scan.status = 'failed';
      scan.errors.push('Scan cancelled by user');
      scan.completed_at = new Date().toISOString();
      return true;
    }
    return false;
  }
  
  async generateVulnerabilityReport(scanId: string): Promise<{
    summary: object;
    vulnerabilities: VulnerabilityReport[];
    constitutional_compliance: object;
  }> {
    const scan = this.runningScans.get(scanId);
    if (!scan) {
      throw new Error(`Scan ${scanId} not found`);
    }
    
    return {
      summary: {
        scan_id: scanId,
        total_vulnerabilities: scan.vulnerabilities_found.length,
        critical_vulnerabilities: scan.vulnerabilities_found.filter(v => v.severity === 'critical').length,
        constitutional_violations: scan.vulnerabilities_found.filter(v => 
          Object.values(v.constitutional_impact).includes('violation')
        ).length,
        performance_impact: scan.performance_impact
      },
      vulnerabilities: scan.vulnerabilities_found,
      constitutional_compliance: scan.constitutional_compliance
    };
  }
}

class OwaspZapClient {
  constructor(private config: { host: string; port: number; apiKey: string }) {}
  
  async startSpider(url: string, config: any): Promise<string> {
    // Implementation would call ZAP API
    return crypto.randomUUID();
  }
  
  async getSpiderStatus(spiderId: string): Promise<{ status: string; progress: number }> {
    // Implementation would call ZAP API
    return { status: 'complete', progress: 100 };
  }
  
  async startActiveScan(url: string, config: any): Promise<string> {
    // Implementation would call ZAP API
    return crypto.randomUUID();
  }
  
  async getActiveScanStatus(scanId: string): Promise<{ status: string; progress: number }> {
    // Implementation would call ZAP API
    return { status: 'complete', progress: 100 };
  }
  
  async stopActiveScan(scanId: string): Promise<void> {
    // Implementation would call ZAP API
  }
  
  async getAlerts(): Promise<any[]> {
    // Implementation would call ZAP API
    return [];
  }
}

class ScanPerformanceMonitor {
  private startTime: number = 0;
  private startCpuUsage: number = 0;
  private startMemoryUsage: number = 0;
  
  start(): void {
    this.startTime = Date.now();
    this.startCpuUsage = process.cpuUsage().user;
    this.startMemoryUsage = process.memoryUsage().heapUsed;
  }
  
  getCurrentImpact(): {
    cpu_usage_percent: number;
    network_overhead_percent: number;
    response_time_impact_percent: number;
    total_overhead_percent: number;
  } {
    const currentCpuUsage = process.cpuUsage().user;
    const currentMemoryUsage = process.memoryUsage().heapUsed;
    
    const cpuIncrease = ((currentCpuUsage - this.startCpuUsage) / this.startCpuUsage) * 100;
    const memoryIncrease = ((currentMemoryUsage - this.startMemoryUsage) / this.startMemoryUsage) * 100;
    
    // Simplified calculation for scan performance impact
    const networkOverhead = Math.min(cpuIncrease * 0.3, 5); // Network scans have lower CPU impact
    const responseTimeImpact = Math.max(cpuIncrease, memoryIncrease) * 0.4;
    const totalOverhead = Math.max(cpuIncrease, memoryIncrease, networkOverhead, responseTimeImpact);
    
    return {
      cpu_usage_percent: Math.max(0, cpuIncrease),
      network_overhead_percent: Math.max(0, networkOverhead),
      response_time_impact_percent: Math.max(0, responseTimeImpact),
      total_overhead_percent: Math.max(0, totalOverhead)
    };
  }
  
  getFinalImpact(): {
    cpu_usage_percent: number;
    network_overhead_percent: number;
    response_time_impact_percent: number;
    total_overhead_percent: number;
  } {
    return this.getCurrentImpact();
  }
}