/**
 * VulnerabilityReport Model
 * 
 * @description Vulnerability tracking entity with remediation management and OWASP compliance
 * @constitutional_requirement Security & Privacy First, TypeScript strict mode
 * @entity_specification From specs/022-step-7-2/data-model.md - VulnerabilityReport
 */

import { z } from 'zod';

/**
 * Vulnerability severity levels (CVSS 3.1 based)
 */
export const VulnerabilitySeverity = z.enum([
  'critical',  // CVSS 9.0-10.0
  'high',      // CVSS 7.0-8.9
  'medium',    // CVSS 4.0-6.9
  'low',       // CVSS 0.1-3.9
  'info'       // CVSS 0.0
]);

/**
 * Vulnerability categories (OWASP Top 10 based)
 */
export const VulnerabilityCategory = z.enum([
  'broken_access_control',
  'cryptographic_failures',
  'injection',
  'insecure_design',
  'security_misconfiguration',
  'vulnerable_components',
  'identification_failures',
  'software_integrity_failures',
  'logging_monitoring_failures',
  'server_side_request_forgery',
  'ai_model_security',
  'gdpr_compliance',
  'data_privacy'
]);

/**
 * Vulnerability status tracking
 */
export const VulnerabilityStatus = z.enum([
  'discovered',
  'confirmed',
  'triaged',
  'in_progress',
  'resolved',
  'mitigated',
  'accepted_risk',
  'false_positive',
  'wont_fix'
]);

/**
 * Remediation priority levels
 */
export const RemediationPriority = z.enum([
  'immediate',  // Critical constitutional violations
  'urgent',     // High severity, public-facing
  'high',       // Medium-high severity
  'medium',     // Standard timeline
  'low'         // Best effort
]);

/**
 * Vulnerability discovery methods
 */
export const DiscoveryMethod = z.enum([
  'automated_scan',
  'manual_testing',
  'penetration_test',
  'code_review',
  'ai_model_testing',
  'gdpr_compliance_audit',
  'constitutional_review',
  'external_report',
  'bug_bounty'
]);

/**
 * CVSS 3.1 metrics schema
 */
export const CVSSMetricsSchema = z.object({
  attack_vector: z.enum(['network', 'adjacent', 'local', 'physical']),
  attack_complexity: z.enum(['low', 'high']),
  privileges_required: z.enum(['none', 'low', 'high']),
  user_interaction: z.enum(['none', 'required']),
  scope: z.enum(['unchanged', 'changed']),
  confidentiality_impact: z.enum(['none', 'low', 'high']),
  integrity_impact: z.enum(['none', 'low', 'high']),
  availability_impact: z.enum(['none', 'low', 'high']),
  base_score: z.number().min(0).max(10),
  temporal_score: z.number().min(0).max(10).optional(),
  environmental_score: z.number().min(0).max(10).optional()
}).strict();

/**
 * Remediation tracking schema
 */
export const RemediationTrackingSchema = z.object({
  remediation_id: z.string().uuid(),
  assigned_to: z.string().min(1),
  assigned_at: z.string().datetime(),
  target_completion: z.string().datetime(),
  actual_completion: z.string().datetime().optional(),
  remediation_method: z.enum([
    'code_fix',
    'configuration_change',
    'access_control_update',
    'component_upgrade',
    'policy_change',
    'process_improvement',
    'architectural_change',
    'mitigation_control'
  ]),
  remediation_details: z.string().min(1),
  validation_required: z.boolean(),
  validation_completed: z.boolean(),
  validation_details: z.string().optional(),
  effort_hours: z.number().min(0).optional(),
  cost_estimate: z.number().min(0).optional()
}).strict();

/**
 * Constitutional compliance impact assessment
 */
export const ConstitutionalImpactSchema = z.object({
  affects_phone_protection: z.boolean(),
  affects_business_isolation: z.boolean(),
  affects_gdpr_compliance: z.boolean(),
  affects_rls_policies: z.boolean(),
  affects_performance_limits: z.boolean(),
  constitutional_violation_risk: z.enum(['none', 'low', 'medium', 'high', 'critical']),
  compliance_notes: z.string().optional()
}).strict();

/**
 * Vulnerability evidence schema
 */
export const VulnerabilityEvidenceSchema = z.object({
  evidence_type: z.enum(['screenshot', 'request_response', 'log_entry', 'code_snippet', 'scan_output']),
  description: z.string().min(1),
  file_path: z.string().optional(),
  content: z.string().optional(),
  timestamp: z.string().datetime(),
  collected_by: z.string().min(1)
}).strict();

/**
 * Vulnerability report schema with strict TypeScript validation
 */
export const VulnerabilityReportSchema = z.object({
  id: z.string().uuid(),
  vulnerability_id: z.string().min(1).max(100), // Internal tracking ID
  
  // Vulnerability details
  title: z.string().min(1).max(200),
  description: z.string().min(1).max(2000),
  category: VulnerabilityCategory,
  severity: VulnerabilitySeverity,
  cvss_metrics: CVSSMetricsSchema,
  
  // Discovery information
  discovery_method: DiscoveryMethod,
  discovered_by: z.string().min(1),
  discovered_at: z.string().datetime(),
  
  // Affected components
  affected_component: z.string().min(1).max(200),
  affected_endpoints: z.array(z.string()).optional(),
  affected_files: z.array(z.string()).optional(),
  affected_versions: z.array(z.string()).optional(),
  
  // Technical details
  cwe_id: z.string().regex(/^CWE-\d+$/).optional(), // Common Weakness Enumeration
  owasp_category: z.string().optional(),
  attack_vector: z.string().min(1),
  exploitation_complexity: z.enum(['trivial', 'easy', 'moderate', 'difficult']),
  
  // Evidence and proof of concept
  evidence: z.array(VulnerabilityEvidenceSchema).min(1),
  proof_of_concept: z.string().optional(),
  reproduction_steps: z.array(z.string()).min(1),
  
  // Impact assessment
  business_impact: z.string().min(1),
  technical_impact: z.string().min(1),
  constitutional_impact: ConstitutionalImpactSchema,
  
  // Status and lifecycle
  status: VulnerabilityStatus,
  remediation_priority: RemediationPriority,
  remediation_tracking: RemediationTrackingSchema.optional(),
  
  // Timeline tracking
  confirmed_at: z.string().datetime().optional(),
  triaged_at: z.string().datetime().optional(),
  resolved_at: z.string().datetime().optional(),
  
  // Quality assurance
  false_positive_likelihood: z.number().min(0).max(100), // Percentage
  validation_required: z.boolean(),
  peer_reviewed: z.boolean(),
  management_approval_required: z.boolean(),
  
  // Risk management
  risk_score: z.number().min(0).max(100),
  exploitability_score: z.number().min(0).max(100),
  impact_score: z.number().min(0).max(100),
  mitigation_controls: z.array(z.string()).optional(),
  
  // Metadata
  created_by: z.string().min(1),
  created_at: z.string().datetime(),
  updated_at: z.string().datetime(),
  tags: z.array(z.string()).optional()
}).strict();

export type VulnerabilityReport = z.infer<typeof VulnerabilityReportSchema>;
export type VulnerabilitySeverityType = z.infer<typeof VulnerabilitySeverity>;
export type VulnerabilityCategoryType = z.infer<typeof VulnerabilityCategory>;
export type VulnerabilityStatusType = z.infer<typeof VulnerabilityStatus>;
export type RemediationPriorityType = z.infer<typeof RemediationPriority>;
export type CVSSMetrics = z.infer<typeof CVSSMetricsSchema>;
export type RemediationTracking = z.infer<typeof RemediationTrackingSchema>;
export type ConstitutionalImpact = z.infer<typeof ConstitutionalImpactSchema>;
export type VulnerabilityEvidence = z.infer<typeof VulnerabilityEvidenceSchema>;

/**
 * Vulnerability report validation and business logic
 */
export class VulnerabilityReportModel {
  /**
   * Validate vulnerability report data
   */
  static validate(data: unknown): VulnerabilityReport {
    return VulnerabilityReportSchema.parse(data);
  }

  /**
   * Create new vulnerability report with validation
   */
  static create(data: Omit<VulnerabilityReport, 'id' | 'created_at' | 'updated_at' | 'status' | 'risk_score' | 'exploitability_score' | 'impact_score'>): VulnerabilityReport {
    const now = new Date().toISOString();
    
    // Calculate risk scores
    const riskScores = this.calculateRiskScores(data.cvss_metrics, data.constitutional_impact);
    
    const report: VulnerabilityReport = {
      ...data,
      id: crypto.randomUUID(),
      status: 'discovered',
      risk_score: riskScores.risk_score,
      exploitability_score: riskScores.exploitability_score,
      impact_score: riskScores.impact_score,
      created_at: now,
      updated_at: now
    };

    // Validate constitutional compliance impact
    this.validateConstitutionalImpact(report);

    return this.validate(report);
  }

  /**
   * Calculate comprehensive risk scores
   */
  static calculateRiskScores(cvss: CVSSMetrics, constitutionalImpact: ConstitutionalImpact): {
    risk_score: number;
    exploitability_score: number;
    impact_score: number;
  } {
    // Base CVSS exploitability score
    let exploitabilityScore = cvss.base_score * 10;
    
    // Adjust for attack complexity
    if (cvss.attack_complexity === 'high') exploitabilityScore *= 0.8;
    if (cvss.privileges_required === 'high') exploitabilityScore *= 0.7;
    if (cvss.user_interaction === 'required') exploitabilityScore *= 0.8;

    // Base CVSS impact score
    let impactScore = cvss.base_score * 10;
    
    // Constitutional impact amplification
    if (constitutionalImpact.constitutional_violation_risk === 'critical') {
      impactScore = Math.min(100, impactScore * 1.5);
    } else if (constitutionalImpact.constitutional_violation_risk === 'high') {
      impactScore = Math.min(100, impactScore * 1.3);
    }

    // Specific constitutional concerns
    if (constitutionalImpact.affects_phone_protection) impactScore += 15;
    if (constitutionalImpact.affects_business_isolation) impactScore += 15;
    if (constitutionalImpact.affects_gdpr_compliance) impactScore += 20;
    if (constitutionalImpact.affects_rls_policies) impactScore += 10;

    // Overall risk score (combination of exploitability and impact)
    const riskScore = Math.min(100, (exploitabilityScore * 0.4) + (impactScore * 0.6));

    return {
      risk_score: Math.round(riskScore),
      exploitability_score: Math.round(Math.min(100, exploitabilityScore)),
      impact_score: Math.round(Math.min(100, impactScore))
    };
  }

  /**
   * Validate constitutional compliance impact
   */
  static validateConstitutionalImpact(report: VulnerabilityReport): boolean {
    const { constitutional_impact } = report;

    // Critical constitutional violations require immediate priority
    if (constitutional_impact.constitutional_violation_risk === 'critical' && 
        report.remediation_priority !== 'immediate') {
      throw new Error('Constitutional violation: Critical constitutional risks require immediate remediation priority');
    }

    // Phone number protection vulnerabilities must be high priority
    if (constitutional_impact.affects_phone_protection && 
        !['immediate', 'urgent'].includes(report.remediation_priority)) {
      throw new Error('Constitutional violation: Phone number protection vulnerabilities require urgent attention');
    }

    // GDPR compliance issues must be prioritized
    if (constitutional_impact.affects_gdpr_compliance && 
        report.remediation_priority === 'low') {
      throw new Error('Constitutional violation: GDPR compliance vulnerabilities cannot be low priority');
    }

    return true;
  }

  /**
   * Determine remediation priority based on severity and constitutional impact
   */
  static determineRemediationPriority(
    severity: VulnerabilitySeverityType,
    constitutionalImpact: ConstitutionalImpact,
    isPublicFacing: boolean = false
  ): RemediationPriorityType {
    // Constitutional violations always get priority treatment
    if (constitutionalImpact.constitutional_violation_risk === 'critical') {
      return 'immediate';
    }

    // Phone number or GDPR issues are urgent
    if (constitutionalImpact.affects_phone_protection || constitutionalImpact.affects_gdpr_compliance) {
      return severity === 'critical' ? 'immediate' : 'urgent';
    }

    // Standard prioritization
    switch (severity) {
      case 'critical':
        return isPublicFacing ? 'immediate' : 'urgent';
      case 'high':
        return isPublicFacing ? 'urgent' : 'high';
      case 'medium':
        return 'medium';
      case 'low':
      case 'info':
        return 'low';
    }
  }

  /**
   * Calculate SLA deadline based on priority and constitutional requirements
   */
  static calculateSLADeadline(priority: RemediationPriorityType, discoveredAt: string): string {
    const discoveryTime = new Date(discoveredAt);
    let hoursToAdd: number;

    switch (priority) {
      case 'immediate':
        hoursToAdd = 24;  // 1 day for constitutional violations
        break;
      case 'urgent':
        hoursToAdd = 72;  // 3 days for urgent issues
        break;
      case 'high':
        hoursToAdd = 168; // 1 week for high priority
        break;
      case 'medium':
        hoursToAdd = 720; // 1 month for medium priority
        break;
      case 'low':
        hoursToAdd = 2160; // 3 months for low priority
        break;
    }

    return new Date(discoveryTime.getTime() + (hoursToAdd * 60 * 60 * 1000)).toISOString();
  }

  /**
   * Update vulnerability status with validation
   */
  static updateStatus(
    report: VulnerabilityReport,
    newStatus: VulnerabilityStatusType,
    updatedBy: string,
    details?: string
  ): VulnerabilityReport {
    const now = new Date().toISOString();

    // Validate status transitions
    this.validateStatusTransition(report.status, newStatus);

    const updatedReport: VulnerabilityReport = {
      ...report,
      status: newStatus,
      updated_at: now,
      ...(newStatus === 'confirmed' && { confirmed_at: now }),
      ...(newStatus === 'triaged' && { triaged_at: now }),
      ...(newStatus === 'resolved' && { resolved_at: now })
    };

    return this.validate(updatedReport);
  }

  /**
   * Add remediation tracking to vulnerability
   */
  static assignRemediation(
    report: VulnerabilityReport,
    assignedTo: string,
    targetCompletion: string,
    remediationMethod: RemediationTracking['remediation_method'],
    details: string
  ): VulnerabilityReport {
    const now = new Date().toISOString();

    const remediation: RemediationTracking = {
      remediation_id: crypto.randomUUID(),
      assigned_to: assignedTo,
      assigned_at: now,
      target_completion: targetCompletion,
      remediation_method: remediationMethod,
      remediation_details: details,
      validation_required: ['critical', 'high'].includes(report.severity),
      validation_completed: false
    };

    const updatedReport: VulnerabilityReport = {
      ...report,
      status: 'in_progress',
      remediation_tracking: remediation,
      updated_at: now
    };

    return this.validate(updatedReport);
  }

  /**
   * Filter vulnerabilities by criteria
   */
  static filterByCriteria(
    reports: VulnerabilityReport[],
    criteria: {
      severity?: VulnerabilitySeverityType | VulnerabilitySeverityType[];
      status?: VulnerabilityStatusType | VulnerabilityStatusType[];
      category?: VulnerabilityCategoryType;
      constitutional_risk?: ConstitutionalImpact['constitutional_violation_risk'];
      assigned_to?: string;
      overdue?: boolean;
    }
  ): VulnerabilityReport[] {
    return reports.filter(report => {
      // Severity filter
      if (criteria.severity) {
        const severities = Array.isArray(criteria.severity) ? criteria.severity : [criteria.severity];
        if (!severities.includes(report.severity)) return false;
      }

      // Status filter
      if (criteria.status) {
        const statuses = Array.isArray(criteria.status) ? criteria.status : [criteria.status];
        if (!statuses.includes(report.status)) return false;
      }

      // Category filter
      if (criteria.category && report.category !== criteria.category) return false;

      // Constitutional risk filter
      if (criteria.constitutional_risk && 
          report.constitutional_impact.constitutional_violation_risk !== criteria.constitutional_risk) {
        return false;
      }

      // Assignment filter
      if (criteria.assigned_to && 
          report.remediation_tracking?.assigned_to !== criteria.assigned_to) {
        return false;
      }

      // Overdue filter
      if (criteria.overdue !== undefined) {
        const isOverdue = report.remediation_tracking ? 
          new Date(report.remediation_tracking.target_completion) < new Date() : false;
        if (criteria.overdue !== isOverdue) return false;
      }

      return true;
    });
  }

  /**
   * Generate vulnerability metrics summary
   */
  static generateMetrics(reports: VulnerabilityReport[]): {
    total_vulnerabilities: number;
    by_severity: Record<VulnerabilitySeverityType, number>;
    by_status: Record<VulnerabilityStatusType, number>;
    constitutional_risks: number;
    overdue_remediations: number;
    average_cvss_score: number;
    sla_compliance_rate: number;
  } {
    const bySeverity = {} as Record<VulnerabilitySeverityType, number>;
    const byStatus = {} as Record<VulnerabilityStatusType, number>;
    
    // Initialize counters
    (['critical', 'high', 'medium', 'low', 'info'] as VulnerabilitySeverityType[]).forEach(s => bySeverity[s] = 0);
    (['discovered', 'confirmed', 'triaged', 'in_progress', 'resolved', 'mitigated', 'accepted_risk', 'false_positive', 'wont_fix'] as VulnerabilityStatusType[]).forEach(s => byStatus[s] = 0);

    let totalCvssScore = 0;
    let constitutionalRisks = 0;
    let overdueRemediations = 0;
    let slaCompliant = 0;

    reports.forEach(report => {
      bySeverity[report.severity]++;
      byStatus[report.status]++;
      totalCvssScore += report.cvss_metrics.base_score;

      if (report.constitutional_impact.constitutional_violation_risk !== 'none') {
        constitutionalRisks++;
      }

      if (report.remediation_tracking) {
        const isOverdue = new Date(report.remediation_tracking.target_completion) < new Date();
        if (isOverdue && !['resolved', 'mitigated'].includes(report.status)) {
          overdueRemediations++;
        } else {
          slaCompliant++;
        }
      }
    });

    return {
      total_vulnerabilities: reports.length,
      by_severity: bySeverity,
      by_status: byStatus,
      constitutional_risks: constitutionalRisks,
      overdue_remediations: overdueRemediations,
      average_cvss_score: reports.length > 0 ? totalCvssScore / reports.length : 0,
      sla_compliance_rate: reports.length > 0 ? (slaCompliant / reports.length) * 100 : 100
    };
  }

  /**
   * Validate status transition rules
   */
  private static validateStatusTransition(currentStatus: VulnerabilityStatusType, newStatus: VulnerabilityStatusType): boolean {
    const validTransitions: Record<VulnerabilityStatusType, VulnerabilityStatusType[]> = {
      'discovered': ['confirmed', 'false_positive'],
      'confirmed': ['triaged', 'false_positive'],
      'triaged': ['in_progress', 'accepted_risk', 'wont_fix'],
      'in_progress': ['resolved', 'mitigated', 'triaged'],
      'resolved': ['confirmed'], // Regression
      'mitigated': ['resolved', 'confirmed'],
      'accepted_risk': ['triaged'], // Re-evaluate
      'false_positive': ['discovered'], // Re-open
      'wont_fix': ['triaged'] // Re-evaluate
    };

    if (!validTransitions[currentStatus]?.includes(newStatus)) {
      throw new Error(`Invalid status transition: ${currentStatus} → ${newStatus}`);
    }

    return true;
  }
}