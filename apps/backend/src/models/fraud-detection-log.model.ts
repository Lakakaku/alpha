import type { FraudDetectionLog } from '@vocilia/types';

/**
 * FraudDetectionLog model for database operations
 * Represents fraud detection and rate limiting logs
 */
export class FraudDetectionLogModel {
  public readonly log_id: string;
  public readonly store_id: string;
  public readonly ip_address: string;
  public readonly user_agent: string;
  public readonly access_timestamp: Date;
  public readonly risk_factors: string[];
  public readonly session_token: string | null;

  constructor(data: FraudDetectionLog) {
    this.log_id = data.log_id;
    this.store_id = data.store_id;
    this.ip_address = data.ip_address;
    this.user_agent = data.user_agent;
    this.access_timestamp = data.access_timestamp;
    this.risk_factors = data.risk_factors;
    this.session_token = data.session_token || null;
  }

  /**
   * Check if log indicates high risk activity
   */
  public isHighRisk(): boolean {
    const highRiskFactors = [
      'excessive_attempts',
      'rate_limit_exceeded',
      'suspicious_user_agent',
      'rapid_succession'
    ];
    
    return this.risk_factors.some(factor => highRiskFactors.includes(factor));
  }

  /**
   * Check if log is within specified time window (in minutes)
   */
  public isWithinTimeWindow(windowMinutes: number): boolean {
    const now = new Date();
    const windowMs = windowMinutes * 60 * 1000;
    const timeDiff = now.getTime() - this.access_timestamp.getTime();
    
    return timeDiff <= windowMs;
  }

  /**
   * Get age of log in minutes
   */
  public getAgeInMinutes(): number {
    const now = new Date();
    const ageMs = now.getTime() - this.access_timestamp.getTime();
    return Math.floor(ageMs / (1000 * 60));
  }

  /**
   * Check if log has specific risk factor
   */
  public hasRiskFactor(factor: string): boolean {
    return this.risk_factors.includes(factor);
  }

  /**
   * Get risk level based on factors
   */
  public getRiskLevel(): 'low' | 'medium' | 'high' | 'blocked' {
    if (this.hasRiskFactor('rate_limit_exceeded')) {
      return 'blocked';
    }
    
    if (this.hasRiskFactor('excessive_attempts')) {
      return 'high';
    }
    
    if (this.risk_factors.length >= 2) {
      return 'medium';
    }
    
    if (this.risk_factors.length > 0) {
      return 'medium';
    }
    
    return 'low';
  }

  /**
   * Convert to plain object for database operations
   */
  public toObject(): FraudDetectionLog {
    return {
      log_id: this.log_id,
      store_id: this.store_id,
      ip_address: this.ip_address,
      user_agent: this.user_agent,
      access_timestamp: this.access_timestamp,
      risk_factors: this.risk_factors,
      session_token: this.session_token
    };
  }

  /**
   * Create from database row
   */
  public static fromDatabaseRow(row: any): FraudDetectionLogModel {
    return new FraudDetectionLogModel({
      log_id: row.log_id,
      store_id: row.store_id,
      ip_address: row.ip_address,
      user_agent: row.user_agent,
      access_timestamp: new Date(row.access_timestamp),
      risk_factors: row.risk_factors || [],
      session_token: row.session_token
    });
  }

  /**
   * Create new fraud detection log
   */
  public static createNew(
    storeId: string,
    ipAddress: string,
    userAgent: string,
    sessionToken: string | null,
    riskFactors: string[]
  ): FraudDetectionLogModel {
    return new FraudDetectionLogModel({
      log_id: '', // Will be generated by database
      store_id: storeId,
      ip_address: ipAddress,
      user_agent: userAgent,
      access_timestamp: new Date(),
      risk_factors: riskFactors,
      session_token: sessionToken
    });
  }

  /**
   * Create log for database insertion (without ID)
   */
  public toCreateObject(): Omit<FraudDetectionLog, 'log_id'> {
    return {
      store_id: this.store_id,
      ip_address: this.ip_address,
      user_agent: this.user_agent,
      access_timestamp: this.access_timestamp,
      risk_factors: this.risk_factors,
      session_token: this.session_token
    };
  }

  /**
   * Filter logs by time window
   */
  public static filterByTimeWindow(
    logs: FraudDetectionLogModel[], 
    windowMinutes: number
  ): FraudDetectionLogModel[] {
    return logs.filter(log => log.isWithinTimeWindow(windowMinutes));
  }

  /**
   * Count logs by risk factors
   */
  public static countByRiskFactors(
    logs: FraudDetectionLogModel[]
  ): Record<string, number> {
    const counts: Record<string, number> = {};
    
    logs.forEach(log => {
      log.risk_factors.forEach(factor => {
        counts[factor] = (counts[factor] || 0) + 1;
      });
    });
    
    return counts;
  }

  /**
   * Get unique IP addresses from logs
   */
  public static getUniqueIPs(logs: FraudDetectionLogModel[]): string[] {
    return [...new Set(logs.map(log => log.ip_address))];
  }
}