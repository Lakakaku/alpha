/**
 * Vulnerability Remediation API Endpoints
 *
 * @description POST /api/security/vulnerabilities/{vulnerabilityId}/remediate endpoint for updating remediation status
 * @constitutional_requirement Admin-only access, remediation deadline tracking, TypeScript strict
 * @performance_target <500ms response time for status updates
 */

import { Request, Response, Router } from 'express';
import { z } from 'zod';
import { VulnerabilityAssessmentService } from '../../services/security/VulnerabilityAssessmentService';
import { adminAuthMiddleware } from '../../middleware/admin-auth';
import { errorHandler } from '../../middleware/error-handler';
import { auditLogger } from '../../services/audit/auditLogger';

const router = Router();

// Input validation schemas
const UpdateRemediationParamsSchema = z.object({
  vulnerabilityId: z.string().uuid('Vulnerability ID must be a valid UUID')
});

const UpdateRemediationBodySchema = z.object({
  status: z.enum(['in_progress', 'fixed', 'accepted', 'wont_fix']),
  remediation_notes: z.string()
    .min(1, 'Remediation notes are required')
    .max(1000, 'Remediation notes must be â‰¤1000 characters'),
  estimated_completion: z.string()
    .datetime('Estimated completion must be valid ISO 8601 datetime')
    .optional()
});

/**
 * POST /api/security/vulnerabilities/{vulnerabilityId}/remediate
 *
 * Updates vulnerability remediation status with deadline validation
 * Enforces constitutional remediation timeline requirements
 */
router.post('/vulnerabilities/:vulnerabilityId/remediate', adminAuthMiddleware, async (req: Request, res: Response) => {
  const startTime = Date.now();

  try {
    // Validate parameters and body
    const params = UpdateRemediationParamsSchema.parse(req.params);
    const body = UpdateRemediationBodySchema.parse(req.body);

    // Get vulnerability assessment service instance
    const vulnerabilityService = new VulnerabilityAssessmentService();

    // Retrieve existing vulnerability to validate deadlines
    const existingVulnerability = await vulnerabilityService.getVulnerability(params.vulnerabilityId);

    if (!existingVulnerability) {
      return res.status(404).json({
        error: 'Vulnerability not found',
        resource_id: params.vulnerabilityId
      });
    }

    // Validate constitutional remediation deadline requirements
    const discoveryDate = new Date(existingVulnerability.discovery_date);
    const now = new Date();
    const hoursElapsed = (now.getTime() - discoveryDate.getTime()) / (1000 * 60 * 60);

    // Constitutional deadline validation
    let deadlineViolation: string | null = null;
    if (existingVulnerability.severity === 'critical' && hoursElapsed > 24) {
      deadlineViolation = 'Critical vulnerabilities must be addressed within 24 hours (constitutional requirement)';
    } else if (existingVulnerability.severity === 'high' && hoursElapsed > 72) {
      deadlineViolation = 'High severity vulnerabilities must be addressed within 72 hours (constitutional requirement)';
    }

    // Log deadline violations but allow status updates for documentation
    if (deadlineViolation && body.status !== 'accepted' && body.status !== 'wont_fix') {
      console.warn(`Remediation deadline violation: ${deadlineViolation} for vulnerability ${params.vulnerabilityId}`);
    }

    // Validate estimated completion date if provided
    if (body.estimated_completion) {
      const estimatedDate = new Date(body.estimated_completion);
      if (estimatedDate <= now) {
        return res.status(400).json({
          error: 'Invalid estimated completion date',
          details: ['Estimated completion must be in the future']
        });
      }

      // Validate against constitutional deadlines for future remediation
      const estimatedHours = (estimatedDate.getTime() - discoveryDate.getTime()) / (1000 * 60 * 60);
      if (existingVulnerability.severity === 'critical' && estimatedHours > 24) {
        return res.status(400).json({
          error: 'Estimated completion violates constitutional deadline',
          details: ['Critical vulnerabilities must be completed within 24 hours of discovery']
        });
      } else if (existingVulnerability.severity === 'high' && estimatedHours > 72) {
        return res.status(400).json({
          error: 'Estimated completion violates constitutional deadline',
          details: ['High severity vulnerabilities must be completed within 72 hours of discovery']
        });
      }
    }

    // Audit log the remediation status update
    await auditLogger.logVulnerabilityRemediation({
      admin_id: req.user?.id || 'unknown',
      action: 'update_vulnerability_remediation',
      vulnerability_id: params.vulnerabilityId,
      old_status: existingVulnerability.remediation_status,
      new_status: body.status,
      remediation_notes: body.remediation_notes,
      estimated_completion: body.estimated_completion,
      deadline_violation: deadlineViolation,
      timestamp: new Date().toISOString(),
      ip_address: req.ip,
      user_agent: req.get('User-Agent')
    });

    // Update vulnerability remediation status
    const updatedVulnerability = await vulnerabilityService.updateRemediationStatus({
      vulnerability_id: params.vulnerabilityId,
      status: body.status,
      remediation_notes: body.remediation_notes,
      estimated_completion: body.estimated_completion,
      updated_by: req.user?.id || 'unknown'
    });

    // Validate constitutional performance requirement (<500ms)
    const responseTime = Date.now() - startTime;
    if (responseTime > 500) {
      console.warn(`Vulnerability remediation endpoint exceeded 500ms: ${responseTime}ms`);
    }

    // Calculate new remediation deadline based on updated status
    let remediationDeadline: string | undefined;
    if (body.status === 'in_progress') {
      const discoveryDate = new Date(updatedVulnerability.discovery_date);
      let hoursToAdd: number;

      switch (updatedVulnerability.severity) {
        case 'critical':
          hoursToAdd = 24;
          break;
        case 'high':
          hoursToAdd = 72;
          break;
        case 'medium':
          hoursToAdd = 168; // 1 week
          break;
        default:
          hoursToAdd = 720; // 30 days
      }

      remediationDeadline = new Date(
        discoveryDate.getTime() + (hoursToAdd * 60 * 60 * 1000)
      ).toISOString();
    }

    // Return updated vulnerability according to contract
    res.status(200).json({
      id: updatedVulnerability.id,
      type: updatedVulnerability.vulnerability_type,
      severity: updatedVulnerability.severity,
      cve_reference: updatedVulnerability.cve_reference,
      title: updatedVulnerability.title || `${updatedVulnerability.vulnerability_type} in ${updatedVulnerability.affected_component}`,
      description: updatedVulnerability.description,
      affected_component: updatedVulnerability.affected_component,
      discovery_date: updatedVulnerability.discovery_date,
      remediation_status: updatedVulnerability.remediation_status,
      remediation_deadline: remediationDeadline,
      risk_score: updatedVulnerability.risk_score,
      remediation_notes: body.remediation_notes,
      estimated_completion: body.estimated_completion,
      updated_at: new Date().toISOString(),
      deadline_compliance: !deadlineViolation
    });

  } catch (error) {
    if (error instanceof z.ZodError) {
      return res.status(400).json({
        error: 'Invalid request parameters or body',
        details: error.errors.map(err => {
          if (err.path.includes('vulnerabilityId')) {
            return 'vulnerabilityId: Must be a valid UUID format';
          }
          if (err.path.includes('status')) {
            return 'status: Must be one of in_progress, fixed, accepted, wont_fix';
          }
          if (err.path.includes('estimated_completion')) {
            return 'estimated_completion: Must be a valid ISO 8601 datetime';
          }
          return `${err.path.join('.')}: ${err.message}`;
        })
      });
    }

    // Log vulnerability remediation errors
    await auditLogger.logSecurityEvent({
      event_type: 'vulnerability_remediation_error',
      admin_id: req.user?.id || 'unknown',
      vulnerability_id: req.params.vulnerabilityId,
      error_message: error instanceof Error ? error.message : 'Unknown error',
      timestamp: new Date().toISOString(),
      ip_address: req.ip
    });

    throw error; // Let error handler middleware handle it
  }
});

export default router;